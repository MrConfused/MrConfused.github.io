<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">

<meta name="baidu-site-verification" content="gab4jOdmJt" />


  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-flash.min.css?v=1.0.2" rel="stylesheet">




  
  
  <link rel="stylesheet" media="all" href="/lib/Han/dist/han.min.css?v=3.3">




<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="L0sNOT9b93zGdJBP3JyfKdDNXAVabwgGQKmdrLonIQw" />








  <meta name="baidu-site-verification" content="I4xdzT5qdf" />







  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="笔记,IOS,Swift," />










<meta name="description" content="Swift教程  1、基本运算符 赋值运算符无返回值 %运算符为求余，注意负数的运算 元组的元素和长度相同时可以进行笔记（swift标准库只能实现七个元素以内的元组的比较） ？？：空合运算符，为可选类型提供默认值 !a：a为可选类型，对其进行解封，访问其值 a...ba到b内的所有值，包括a和b a..&lt;b 不包括b a... a 到结尾，一般用于访问下标 ...b 开头到b 逻辑运算（&amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="《The Swift Programming Language》in Chinese">
<meta property="og:url" content="https://mrconfused.github.io/%E3%80%8AThe%20Swift%20Programming%20Language%E3%80%8Bin%20Chinese.html">
<meta property="og:site_name" content="出自幽谷，迁于乔木">
<meta property="og:description" content="Swift教程  1、基本运算符 赋值运算符无返回值 %运算符为求余，注意负数的运算 元组的元素和长度相同时可以进行笔记（swift标准库只能实现七个元素以内的元组的比较） ？？：空合运算符，为可选类型提供默认值 !a：a为可选类型，对其进行解封，访问其值 a...ba到b内的所有值，包括a和b a..&lt;b 不包括b a... a 到结尾，一般用于访问下标 ...b 开头到b 逻辑运算（&amp;">
<meta property="article:published_time" content="2020-07-03T15:45:04.744Z">
<meta property="article:modified_time" content="2020-07-05T15:12:05.495Z">
<meta property="article:author" content="LTP">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="IOS">
<meta property="article:tag" content="Swift">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>







  <title>《The Swift Programming Language》in Chinese | 出自幽谷，迁于乔木</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?760eb72b67b1d20ac62682067b9c35d3";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">出自幽谷，迁于乔木</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">有匪君子，如切如磋，如琢如磨</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mrconfused.github.io/%E3%80%8AThe%20Swift%20Programming%20Language%E3%80%8Bin%20Chinese.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LTP">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/upload/image/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="出自幽谷，迁于乔木">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">《The Swift Programming Language》in Chinese</h2>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-07-05T23:12:05+08:00">
                2020-07-05
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IOS/" itemprop="url" rel="index">
                    <span itemprop="name">IOS</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IOS/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        <blockquote>
<p><a href="https://swiftgg.gitbook.io/swift/swift-jiao-cheng" target="_blank" rel="noopener">Swift教程</a></p>
</blockquote>
<h1 id="1、基本运算符"><a href="#1、基本运算符" class="headerlink" title="1、基本运算符"></a>1、基本运算符</h1><ul>
<li>赋值运算符无返回值</li>
<li>%运算符为求余，注意负数的运算</li>
<li>元组的元素和长度相同时可以进行笔记（swift标准库只能实现七个元素以内的元组的比较）</li>
<li>？？：空合运算符，为可选类型提供默认值</li>
<li>!a：a为可选类型，对其进行解封，访问其值</li>
<li><code>a...b</code>a到b内的所有值，包括a和b</li>
<li><code>a..&lt;b</code> 不包括b</li>
<li><code>a...</code> a 到结尾，一般用于访问下标</li>
<li><code>...b</code> 开头到b</li>
<li>逻辑运算（&amp;&amp; 和 ||）是左结合</li>
</ul>
<h1 id="2、字符串String和字符Character"><a href="#2、字符串String和字符Character" class="headerlink" title="2、字符串String和字符Character"></a>2、字符串String和字符Character</h1><ul>
<li>String支持“ + ”连接</li>
<li>“”“  ”“” 多行字符串字面量<ul>
<li>在每一行的结尾加上 \ 标识续行符，此处不换行</li>
<li>开头处或结尾处手动换行，标识在开头或结尾有个换行符</li>
</ul>
</li>
<li>用<code>\</code>转义其他字符</li>
<li>扩展字符串分隔符：<code>#   #</code><ul>
<li>其中的特殊字符不需要转义</li>
</ul>
</li>
<li>空字符串的<code>isempty</code>返回true</li>
<li>将字符串常量赋值给var变量，则该变量可进行更改</li>
<li>字符串是值类型，在对其进行赋值时，会创建副本进行值拷贝</li>
<li><code>+</code>和<code>+=</code>和<code>append()</code>均可连接字符串<ul>
<li>连接时，多行字符串的结尾没有换行</li>
</ul>
</li>
<li><code>&quot;\(variable)&quot;</code>：字符串插值<ul>
<li>会在字符串中插入variable变量</li>
</ul>
</li>
<li>String和character完全兼容Unicode标准</li>
<li><code>count</code>可以获取String的字符数<ul>
<li>必须遍历全部的 Unicode 标量，才能确定字符串的字符数量。</li>
</ul>
</li>
<li>字符串索引<ul>
<li>不同的字符会占用不同的空间，因此索引不能用整数</li>
<li><code>startIndex</code>是String的第一个字符的索引</li>
<li><code>endIndex</code>是String最后一个字符的下一个位置的索引，不是String的有效下标</li>
<li>空字符串的<code>startIndex</code>和<code>endIndex</code>是相等的</li>
<li><code>index(before:)</code>获取前一个索引</li>
<li><code>index(after:)</code>获取后一个索引</li>
<li><code>index(_:offsetBy:)</code>获取一定偏移量的索引</li>
<li><code>indices</code>属性：获取String的全部索引的range</li>
</ul>
</li>
<li><code>insert(_:at:)</code>插入字符</li>
<li><code>remove(at:)</code>删除字符</li>
<li><code>removeSubrange(_:)</code>删除子串</li>
<li><code>Substring</code>实例：从String中截取的用于短时处理的子串，<ul>
<li>Substring和原String共用一段内存空间</li>
<li>Substring和String都遵循<code>StringProtocol</code></li>
</ul>
</li>
<li>字符串比较<ul>
<li>== 和 !=    只要两个字符串的可扩展字型群集相等，他们就像等，即使字符标量不同</li>
<li><code>hasPrefix(_:)</code>和<code>hasSuffix(_:)</code>是否拥有指定的前缀或后缀</li>
</ul>
</li>
<li>字符串的Unicode表现形式<ul>
<li><code>utf8</code>属性：访问一个String的UTF-8表示，是UInt8的值的集合</li>
<li><code>utf16</code>属性：</li>
<li><code>unicodeScalars</code>属性：每个unicodeScalar有一个value属性，可以返回21位的数值，用UInt32表示</li>
</ul>
</li>
</ul>
<h1 id="3、集合类型"><a href="#3、集合类型" class="headerlink" title="3、集合类型"></a>3、集合类型</h1><h2 id="3-1-集合类型"><a href="#3-1-集合类型" class="headerlink" title="3.1 集合类型"></a>3.1 集合类型</h2><ul>
<li><p>数组Array：有序</p>
</li>
<li><p>集合Set：无序无重复</p>
</li>
<li><p>字典Dictionary：无序键值对</p>
</li>
<li><p>必须明确其类型</p>
</li>
<li><p>var声明的集合是可变的</p>
</li>
<li><p>let声明的集合不可变</p>
</li>
</ul>
<h2 id="3-2-数组（Array）"><a href="#3-2-数组（Array）" class="headerlink" title="3.2 数组（Array）"></a>3.2 数组（Array）</h2><h3 id="1）构建方法"><a href="#1）构建方法" class="headerlink" title="1）构建方法"></a>1）构建方法</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Int</span>]()	<span class="comment">//空数组</span></span><br><span class="line"><span class="type">Array</span>(repeating: <span class="number">0.0</span>, <span class="built_in">count</span>: <span class="number">3</span>)	<span class="comment">//有默认值的数组</span></span><br><span class="line">array1 + array2	<span class="comment">//两个数组相加</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]	<span class="comment">//用数组字面量构建数组</span></span><br></pre></td></tr></table></figure>

<h3 id="2）访问和修改"><a href="#2）访问和修改" class="headerlink" title="2）访问和修改"></a>2）访问和修改</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 属性</span></span><br><span class="line"><span class="built_in">count</span>	<span class="comment">//可用来判断索引是否有效</span></span><br><span class="line">isEmpty</span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line">append(<span class="number">_</span>:)</span><br><span class="line">arr1 += arr2	<span class="comment">//添加另一个数组的数据</span></span><br><span class="line">arr1[<span class="number">3</span>]	<span class="comment">//下标必须有效</span></span><br><span class="line">arr[<span class="number">4</span>...<span class="number">6</span>] = [<span class="string">"a"</span>, <span class="string">"b"</span>]	<span class="comment">//将arr的第4、5、6个元素换为“a”和“b”，少一个元素</span></span><br><span class="line">insert(<span class="number">_</span>:at:)	<span class="comment">//在指定索引之前添加数据</span></span><br><span class="line">remove(at:)	<span class="comment">//会返回被删除的数据</span></span><br><span class="line">removeLast()</span><br></pre></td></tr></table></figure>

<h3 id="3）数组遍历"><a href="#3）数组遍历" class="headerlink" title="3）数组遍历"></a>3）数组遍历</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> arr1</span><br><span class="line"><span class="keyword">for</span> (index, value) <span class="keyword">in</span> arr1.enumerated()	<span class="comment">//获取索引值及数据</span></span><br></pre></td></tr></table></figure>

<h2 id="3-3-集合（Sets）"><a href="#3-3-集合（Sets）" class="headerlink" title="3.3 集合（Sets）"></a>3.3 集合（Sets）</h2><h3 id="1）集合类型的哈希值"><a href="#1）集合类型的哈希值" class="headerlink" title="1）集合类型的哈希值"></a>1）集合类型的哈希值</h3><p>集合中的类型必须是可哈希化的（哈希值是Int类型，相等的对象哈希值一定相同）</p>
<p>所有基本类型（String、Int、Double、Bool）都是可哈希化的</p>
<p>没有关联值的枚举成员值是可哈希化的</p>
<p>自定义的类型要想作为集合和字典的类型，要遵循<code>Hashable</code>协议，提供一个类型为<code>Int</code>的可读属性<code>hashValue</code>，和<code>==</code>的实现（满足自反性、对称性、传递性）</p>
<h3 id="2）创建集合"><a href="#2）创建集合" class="headerlink" title="2）创建集合"></a>2）创建集合</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span>&lt;<span class="type">Int</span>&gt;()	<span class="comment">//空集合</span></span><br><span class="line"><span class="keyword">var</span> set1: <span class="type">Set</span>&lt;<span class="type">Int</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]	<span class="comment">//Set类型无法被推断，必须显示声明，&lt;Int&gt;可省略</span></span><br><span class="line"><span class="keyword">var</span> set1: <span class="type">Set</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]	<span class="comment">//&lt;Int&gt;可省略</span></span><br></pre></td></tr></table></figure>

<h3 id="3）访问和修改"><a href="#3）访问和修改" class="headerlink" title="3）访问和修改"></a>3）访问和修改</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 属性</span></span><br><span class="line"><span class="built_in">count</span></span><br><span class="line">isEmpty</span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line">insert(<span class="number">_</span>:)</span><br><span class="line">remove(<span class="number">_</span>:)</span><br><span class="line"><span class="built_in">contains</span>(<span class="number">_</span>:)	<span class="comment">//是否包含某值</span></span><br><span class="line">sorted()	<span class="comment">//返回有序数组</span></span><br></pre></td></tr></table></figure>

<h3 id="4）集合遍历"><a href="#4）集合遍历" class="headerlink" title="4）集合遍历"></a>4）集合遍历</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> set1</span><br></pre></td></tr></table></figure>

<h3 id="5）集合操作"><a href="#5）集合操作" class="headerlink" title="5）集合操作"></a>5）集合操作</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">intersection(<span class="number">_</span>:)	<span class="comment">//返回交集</span></span><br><span class="line">symmetricDifference(<span class="number">_</span>:)	<span class="comment">//返回不相交的集合</span></span><br><span class="line">union(<span class="number">_</span>:)	<span class="comment">//返回全集</span></span><br><span class="line">subtracting(<span class="number">_</span>:)	<span class="comment">//返回减去另一个集合的值的集合</span></span><br><span class="line"></span><br><span class="line">==	<span class="comment">//是否相等</span></span><br><span class="line">isSubset(of:)	<span class="comment">//是否是指定集合的子集</span></span><br><span class="line">isStrictSubset(of:)	<span class="comment">//是否是指定集合的严格子集(不想相等)</span></span><br><span class="line">isSuperset(of:)	<span class="comment">//是否是指定集合超集</span></span><br><span class="line">isStrictSuperset(of:)	<span class="comment">//是否是指定集合的严格超集(不想相等)</span></span><br><span class="line">isDisjoint(with:)	<span class="comment">//是否没有交集</span></span><br></pre></td></tr></table></figure>

<h2 id="3-4-字典（Dictionary）"><a href="#3-4-字典（Dictionary）" class="headerlink" title="3.4 字典（Dictionary）"></a>3.4 字典（Dictionary）</h2><p>Key必须遵循<code>Hashable</code>协议</p>
<h3 id="1）创建字典"><a href="#1）创建字典" class="headerlink" title="1）创建字典"></a>1）创建字典</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Int</span>: <span class="type">String</span>]()	<span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> airports: [<span class="type">String</span>: <span class="type">String</span>] = [<span class="string">"a"</span>: <span class="string">"aa"</span>, <span class="string">"c"</span>: <span class="string">"cc"</span>]	<span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> airports = [<span class="string">"a"</span>: <span class="string">"aa"</span>, <span class="string">"c"</span>: <span class="string">"cc"</span>]</span><br></pre></td></tr></table></figure>

<h3 id="2）访问和修改-1"><a href="#2）访问和修改-1" class="headerlink" title="2）访问和修改"></a>2）访问和修改</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">count</span></span><br><span class="line">isEmpty</span><br><span class="line">dic[key] = newValue	<span class="comment">//可添加新值，可修改旧值</span></span><br><span class="line">updateValue(<span class="number">_</span>:forKey:)	<span class="comment">//可添加新值，可修改旧值；返回旧值的可选类型，不存在则返回nil</span></span><br><span class="line">dic[key] = <span class="literal">nil</span>	<span class="comment">//删除key对应的键值对</span></span><br><span class="line">removeValue(forKey:)	<span class="comment">//若存在则移除，若没有则返回nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可用下标检索，判断key对应的值是否存在</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> value = dic[key] &#123; &#125;	<span class="comment">//存在</span></span><br><span class="line"><span class="keyword">else</span> &#123; &#125;	<span class="comment">//不存在</span></span><br></pre></td></tr></table></figure>

<h3 id="3）字典遍历"><a href="#3）字典遍历" class="headerlink" title="3）字典遍历"></a>3）字典遍历</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> dic	<span class="comment">//遍历每对键值对</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dic.keys	<span class="comment">//遍历所有的键，dic无序，但是可对dic.keys排序来顺序遍历dic</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> dic.values	<span class="comment">//遍历所有的值</span></span><br></pre></td></tr></table></figure>

<h1 id="4、控制流"><a href="#4、控制流" class="headerlink" title="4、控制流"></a>4、控制流</h1><h2 id="4-1-for-in"><a href="#4-1-for-in" class="headerlink" title="4.1 for-in"></a>4.1 for-in</h2><p>可遍历集合、range中的元素</p>
<p>若不需要每个元素值，可用<code>_</code>写在for后面，使得遍历时不访问值</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stride</span>（from:to:by:)	<span class="comment">//提供 [from, to) 区间中每隔by的数字组成的range</span></span><br><span class="line"><span class="built_in">stride</span>(from: <span class="number">0</span>, to: <span class="number">60</span>, by: <span class="number">5</span>)	<span class="comment">//（0, 5, 10, 15 ... 45, 50, 55）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">stride</span>(from:through:by)	<span class="comment">//提供 [from, through] 区间中每隔by的数字组成的range</span></span><br><span class="line"><span class="built_in">stride</span>(from: <span class="number">3</span>, through: <span class="number">12</span>, by: <span class="number">3</span>)	<span class="comment">//（3, 6, 9, 12）</span></span><br></pre></td></tr></table></figure>

<h2 id="4-2-while"><a href="#4-2-while" class="headerlink" title="4.2 while"></a>4.2 while</h2><p><code>while</code>：可以和<code>let</code>一起用，来判断某个可选值是否为nil</p>
<p><code>repeat { } while</code></p>
<h2 id="4-3-条件语句"><a href="#4-3-条件语句" class="headerlink" title="4.3 条件语句"></a>4.3 条件语句</h2><h3 id="1）if"><a href="#1）if" class="headerlink" title="1）if"></a>1）if</h3><p>可以和<code>let</code>一起用，来判断某个可选值是否为nil</p>
<h3 id="2）switch"><a href="#2）switch" class="headerlink" title="2）switch"></a>2）switch</h3><p>不用对每个case手动添加break，若想显式贯穿case分支，可用<code>fallthrough</code>,但他不会检查下一条匹配条件</p>
<p>每个分支不能为空，可用<code>break</code>来忽略该分支</p>
<p>case可匹配区间，判断值是否落入区间</p>
<p>可匹配元组</p>
<p>值绑定：case分支可以将匹配的值赋值给临时变量或常量</p>
<p>while：<code>case let (x, y) while x==y</code></p>
<p>复合型cases：匹配多个可能的值，用逗号隔开</p>
<p>复合匹配的值绑定：必须赋值给相同的变量，且绑定值的类型要相同</p>
<h2 id="4-4-控制转移"><a href="#4-4-控制转移" class="headerlink" title="4.4 控制转移"></a>4.4 控制转移</h2><ul>
<li>conginue</li>
<li>break<ul>
<li>可用来忽略case分支，或者终止循环</li>
</ul>
</li>
<li>fallthrough<ul>
<li>不会检查下一个匹配条件，简单地使代码继续连接到下一个 case 中的代码</li>
</ul>
</li>
<li>return</li>
<li>throw</li>
</ul>
<h3 id="1）带标签的语句"><a href="#1）带标签的语句" class="headerlink" title="1）带标签的语句"></a>1）带标签的语句</h3><p>可以给循环体添加标签，然后用<code>break</code>或者<code>continue</code>来结束或者继续被标记的语句</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">label name: <span class="keyword">while</span> condition &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2）guard"><a href="#2）guard" class="headerlink" title="2）guard"></a>2）guard</h3><p>guard和if的功能一样，不同的是guard后面一定要有else，且else中要有控制转移语句。</p>
<p>将可选值的绑定作为guard的条件，可以保护guard后面的代码。</p>
<p>可以在紧邻条件判断的地方处理违规的情况。</p>
<h2 id="4-5-检测API可用性"><a href="#4-5-检测API可用性" class="headerlink" title="4.5 检测API可用性"></a>4.5 检测API可用性</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可用在if或者guard语句中。*一定要有，指定在更高版本也适用</span></span><br><span class="line"><span class="keyword">if</span> #available(iOS <span class="number">10</span>, macOS <span class="number">10.12</span>, *) &#123;</span><br><span class="line">    <span class="comment">// 在 iOS 使用 iOS 10 的 API, 在 macOS 使用 macOS 10.12 的 API</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 使用先前版本的 iOS 和 macOS 的 API</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="5、函数"><a href="#5、函数" class="headerlink" title="5、函数"></a>5、函数</h1><h2 id="5-1-可变参数"><a href="#5-1-可变参数" class="headerlink" title="5.1 可变参数"></a>5.1 可变参数</h2><blockquote>
<p>参数的数量不确定</p>
</blockquote>
<p>在参数的类型后面加上<code>...</code></p>
<p>例如：<code>numbers: Double...</code>在函数中会变为数组<code>[Double]</code></p>
<p>一个函数最多允许有一个可变参数</p>
<h2 id="5-2-输入输出参数"><a href="#5-2-输入输出参数" class="headerlink" title="5.2 输入输出参数"></a>5.2 输入输出参数</h2><blockquote>
<p>在函数中可被更改，且函数返回后仍然存在</p>
</blockquote>
<p>在参数类型前加<code>inout</code>,调用时要在变量前面加上<code>&amp;</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testInout</span><span class="params">(<span class="number">_</span> a: <span class="keyword">inout</span> Int)</span></span>&#123; a += <span class="number">1</span> &#125;	<span class="comment">// 函数定义</span></span><br><span class="line"><span class="keyword">var</span> num: <span class="type">Int</span> = <span class="number">3</span></span><br><span class="line">testInout(&amp;num)	<span class="comment">// 函数调用</span></span><br></pre></td></tr></table></figure>

<h2 id="5-3-函数类型"><a href="#5-3-函数类型" class="headerlink" title="5.3 函数类型"></a>5.3 函数类型</h2><p>函数类型可像基本类型一样使用</p>
<h3 id="1）作为参数类型"><a href="#1）作为参数类型" class="headerlink" title="1）作为参数类型"></a>1）作为参数类型</h3><p>可以将函数的部分实现留给调用者实现</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fucn printMathResult(<span class="number">_</span> addTwoInt: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>, <span class="number">_</span> a: <span class="type">Int</span>, <span class="number">_</span> b: <span class="type">Int</span>)&#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"\(addTwoInt(a, b))"</span>)</span><br><span class="line">&#125;</span><br><span class="line">printMathResult(myFunc, <span class="number">1</span>, <span class="number">2</span>)	<span class="comment">// 自己实现加法函数，并将其传给printMathResult</span></span><br></pre></td></tr></table></figure>

<h3 id="2）作为返回值类型"><a href="#2）作为返回值类型" class="headerlink" title="2）作为返回值类型"></a>2）作为返回值类型</h3><h2 id="5-4-嵌套函数"><a href="#5-4-嵌套函数" class="headerlink" title="5.4 嵌套函数"></a>5.4 嵌套函数</h2><h1 id="6、闭包"><a href="#6、闭包" class="headerlink" title="6、闭包"></a>6、闭包</h1><blockquote>
<p>函数代码块，类似于C++的Lambda和OC的Block</p>
<p>可以捕获和存储上下文的变量的引用</p>
</blockquote>
<p>闭包有三种形式：</p>
<ol>
<li>全局函数：有名字，但不会捕获任何值</li>
<li>嵌套函数：有名字，可以捕获所在函数内的值</li>
<li>闭包表达式：匿名，可以捕获上下文的变量，不能设定默认值</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; (parameters) -&gt; returnType <span class="keyword">in</span></span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-1-优化"><a href="#6-1-优化" class="headerlink" title="6.1 优化"></a>6.1 优化</h2><p><code>names.sorted(by: { (s1: String, s2: String) -&gt; Bool in  return s1&gt;s2 })</code>优化：</p>
<ol>
<li><p>利用上下文推断参数和返回类型（可省略参数和返回类型）</p>
<p><code>names.sorted(by: { s1, s2 in return s1&gt;s2 })</code></p>
</li>
<li><p>隐式返回单表达式（单表达式可省略 return）</p>
<p><code>names.sorted(by: { s1, s2 in s1&gt;s2 })</code></p>
</li>
<li><p>参数名称缩写（可使用$0, $1）</p>
<p><code>names.sorted(by: { $0&gt;$1 })</code></p>
<p><code>names.sorted(by: { &gt; })</code>    String的<code>&gt;</code>方法是个接收两个String并返回Bool的函数</p>
</li>
<li><p>尾随闭包语法</p>
<p>是个写在函数的<code>()</code>之后的闭包表达式，函数可将其作为最后一个参数调用，且不用写出他的参数标签：</p>
<p><code>names.sorted() { $0 &gt; $1 }</code></p>
<p>若只有该闭包一个参数，可省掉<code>()</code>：</p>
<p><code>names.sorted { $0 &gt; $1 }</code></p>
</li>
</ol>
<h2 id="6-2-值捕获"><a href="#6-2-值捕获" class="headerlink" title="6.2 值捕获"></a>6.2 值捕获</h2><p>闭包捕获的是值的引用</p>
<p>若某值不会被闭包改变，swift会为捕获的值创建一份值拷贝</p>
<p>若一个类实例的属性是闭包，且该闭包通过访问该实例而捕获了该实例，会导致循环引用。可用<a href="https://swiftgg.gitbook.io/swift/swift-jiao-cheng/24_automatic_reference_counting#strong-reference-cycles-for-closures" target="_blank" rel="noopener">捕获列表</a>解决。</p>
<h2 id="6-3-闭包是引用类型"><a href="#6-3-闭包是引用类型" class="headerlink" title="6.3 闭包是引用类型"></a>6.3 闭包是引用类型</h2><p>将函数或闭包赋值给一个常量，实际是将该常量的值设置为函数或闭包的引用，常量的值不能改变，但是函数或闭包可以改变</p>
<h2 id="6-4-逃逸闭包"><a href="#6-4-逃逸闭包" class="headerlink" title="6.4 逃逸闭包"></a>6.4 逃逸闭包</h2><blockquote>
<p>当一个闭包作为参数传入一个函数中，但是这个闭包在函数返回之后才被执行，则该闭包是逃逸闭包</p>
</blockquote>
<p>使闭包逃逸：将闭包保存在一个函数外部定义的变量中。</p>
<p>在定义函数时，可在接收闭包的参数前加上<code>@escaping</code>，指明这个闭包允许逃逸。</p>
<p>将闭包标记为<code>@escaping</code>那么在闭包中必须显式引用<code>self</code></p>
<p>举个例子，很多启动异步操作的函数接受一个闭包参数作为 completion handler。这类函数会在异步操作开始之后立刻返回，但是闭包直到异步操作结束后才会被调用。</p>
<h2 id="6-5-自动闭包"><a href="#6-5-自动闭包" class="headerlink" title="6.5 自动闭包"></a>6.5 自动闭包</h2><blockquote>
<p>自动创建的闭包，用于包装传递给函数作为参数的表达式</p>
</blockquote>
<p>在定义函数时，可在接收闭包的参数前加上<code>autoclosure</code>，指明该参数会自动包装为闭包。</p>
<p>可以省略花括号，但是导致代码难以理解。</p>
<h1 id="7、枚举"><a href="#7、枚举" class="headerlink" title="7、枚举"></a>7、枚举</h1><h2 id="7-1-语法"><a href="#7-1-语法" class="headerlink" title="7.1 语法"></a>7.1 语法</h2><blockquote>
<p>枚举类型首字母大写</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">EnumName</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> a</span><br><span class="line">  <span class="keyword">case</span> b, <span class="built_in">c</span>, d</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若一个enum变量的类型已知，对该变量再次赋值时可以省略enum类型，直接用<code>.a</code>对其赋值</p>
<h2 id="7-2-用Switch语句匹配枚举值"><a href="#7-2-用Switch语句匹配枚举值" class="headerlink" title="7.2 用Switch语句匹配枚举值"></a>7.2 用Switch语句匹配枚举值</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">EnumName</span> enum1 = <span class="type">EnumName</span>.a</span><br><span class="line"><span class="keyword">switch</span> enum1 &#123;</span><br><span class="line">	<span class="keyword">case</span> .a:</span><br><span class="line">  	..........</span><br><span class="line">  <span class="keyword">case</span> .b:</span><br><span class="line">  	..........</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  	..........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-3-enum成员对遍历"><a href="#7-3-enum成员对遍历" class="headerlink" title="7.3 enum成员对遍历"></a>7.3 enum成员对遍历</h2><p>令该enum遵循<code>CaseIterable</code>协议，则可用<code>unum1.allClass</code>得到所有成员，每个成员都是enum1类型的实例。</p>
<h2 id="7-4-关联值"><a href="#7-4-关联值" class="headerlink" title="7.4 关联值"></a>7.4 关联值</h2><p>在7.1节中的a、b、c、d称为成员值，此外还可把成员值和其他类型的值（关联值）一起存储。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">BarCode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> upc(<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>)	<span class="comment">//成员值为upc，关联值类型为(Int, Int, Int, Int)</span></span><br><span class="line">  <span class="keyword">case</span> qrCode(<span class="type">String</span>)	<span class="comment">//成员值为qrCode，关联值类型为String</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> productCode = <span class="type">BarCode</span>.upc(<span class="number">8</span>, <span class="number">85909</span>, <span class="number">51226</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>在switch语句中也可把每个关联值提取出来</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> productCode &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">let</span> .udp(numberSystem, manufacturer, product, check):</span><br><span class="line">  	...........</span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">let</span> .qrCode(prodectQrCode)</span><br><span class="line">  	...........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-5-原始值-默认值"><a href="#7-5-原始值-默认值" class="headerlink" title="7.5 原始值/默认值"></a>7.5 原始值/默认值</h2><p>可为每个成员值声明一个默认值（不可改变）</p>
<p>要在声明的enum名字后面加上<code>: &lt;rawType&gt;</code>来声明原始值的类型</p>
<p>使用成员的<code>rawValue</code>属性可访问该成员的原始值</p>
<h3 id="1）原始值的隐式赋值"><a href="#1）原始值的隐式赋值" class="headerlink" title="1）原始值的隐式赋值"></a>1）原始值的隐式赋值</h3><p>原始值为整型或者String类型时，swift会自动赋值</p>
<p>整数时：第一个成员默认为0或者显式设置，之后每个原始值递增1</p>
<p>String时：默认为成员的名字</p>
<h3 id="2）使用原始值初始化枚举实例"><a href="#2）使用原始值初始化枚举实例" class="headerlink" title="2）使用原始值初始化枚举实例"></a>2）使用原始值初始化枚举实例</h3><p>若在定义enum类型的时候使用了原始值，则会自动获得一个接受<code>rawValue</code>参数的初始化方法返回枚举类型或者nil。</p>
<p>若没有对应的原始值则返回nil</p>
<h2 id="7-6-递归枚举"><a href="#7-6-递归枚举" class="headerlink" title="7.6 递归枚举"></a>7.6 递归枚举</h2><p>是一种枚举类型，存在成员使用该枚举类型作为关联值。</p>
<p>可在成员前加上<code>indirect</code>表示该成员可递归，或者在枚举类型开头加上<code>indirect</code>表示所有成员均可递归。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">indirect</span> <span class="class"><span class="keyword">enum</span> <span class="title">ArithmeticExpression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> num(<span class="type">Int</span>)</span><br><span class="line">  	<span class="keyword">case</span> add(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">  	<span class="keyword">case</span> multip(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> two = <span class="type">ArithmeticExpression</span>.num(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> four = <span class="type">ArithmeticExpression</span>.num(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">var</span> five = <span class="type">ArithmeticExpression</span>.num(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">var</span> sum = <span class="type">ArithmeticExpression</span>.add(four, five)</span><br><span class="line"><span class="keyword">var</span> result = <span class="type">ArithmeticExpression</span>.multip(sum, two)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculate</span><span class="params">(<span class="number">_</span> exp: ArithmeticExpression)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> exp &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .num(val):</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .add(a, b):</span><br><span class="line">        <span class="keyword">return</span> calculate(a) + calculate(b)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .multip(a, b):</span><br><span class="line">        <span class="keyword">return</span> calculate(a) * calculate(b)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8、类和结构体"><a href="#8、类和结构体" class="headerlink" title="8、类和结构体"></a>8、类和结构体</h1><ul>
<li>Swift不用把类和结构体的定义与实现分开写</li>
<li>使用首字母大写的驼峰命名法（UpperCamelCase）命名类和结构体</li>
<li>使用lowerCamelCase命名属性和方法</li>
</ul>
<h2 id="8-1-类和结构体的对比"><a href="#8-1-类和结构体的对比" class="headerlink" title="8.1 类和结构体的对比"></a>8.1 类和结构体的对比</h2><h3 id="1）共同点"><a href="#1）共同点" class="headerlink" title="1）共同点"></a>1）共同点</h3><ul>
<li>属性</li>
<li>方法</li>
<li>下标操作</li>
<li>构造器</li>
<li>可以扩展</li>
<li>遵循协议</li>
</ul>
<h3 id="2）类的特点"><a href="#2）类的特点" class="headerlink" title="2）类的特点"></a>2）类的特点</h3><ul>
<li>继承：允许一个类继承另一个类的特性</li>
<li>类型转换：允许在运行时检查和解释一个实例的类型</li>
<li>析构器：允许一个实例可以释放其拥有的资源</li>
<li>引用计数：允许对一个类多次饮用</li>
</ul>
<h3 id="3）类的缺点"><a href="#3）类的缺点" class="headerlink" title="3）类的缺点"></a>3）类的缺点</h3><p>类的上述附加功能，增加了其复杂性</p>
<h3 id="4）结构体的逐一构造器"><a href="#4）结构体的逐一构造器" class="headerlink" title="4）结构体的逐一构造器"></a>4）结构体的逐一构造器</h3><p>结构体有个自动生成的成员逐一构造器</p>
<p>类没有</p>
<h3 id="5）总结"><a href="#5）总结" class="headerlink" title="5）总结"></a>5）总结</h3><p><a href="https://developer.apple.com/documentation/swift/choosing_between_structures_and_classes" target="_blank" rel="noopener">优先使用<strong>结构体</strong>，必要时（使用了OC的API、需要Control Identity）才用类。</a></p>
<h2 id="8-2-结构体和枚举是值类型"><a href="#8-2-结构体和枚举是值类型" class="headerlink" title="8.2 结构体和枚举是值类型"></a>8.2 结构体和枚举是<strong>值类型</strong></h2><blockquote>
<p>值类型：被赋值或传递给函数时会被拷贝</p>
</blockquote>
<h2 id="8-3-类是引用类型"><a href="#8-3-类是引用类型" class="headerlink" title="8.3 类是引用类型"></a>8.3 类是<strong>引用类型</strong></h2><blockquote>
<p>赋值时不会拷贝</p>
</blockquote>
<h3 id="1）恒等运算符-和"><a href="#1）恒等运算符-和" class="headerlink" title="1）恒等运算符===和!=="></a>1）恒等运算符<code>===</code>和<code>!==</code></h3><p>用来判断两个变量是否引用同一个类实例</p>
<h3 id="2-指针"><a href="#2-指针" class="headerlink" title="2) 指针"></a>2) <a href="https://developer.apple.com/documentation/swift/swift_standard_library/manual_memory_management" target="_blank" rel="noopener">指针</a></h3><h1 id="9、属性"><a href="#9、属性" class="headerlink" title="9、属性"></a>9、属性</h1><p>存储属性会将变量存储为实例的一部分，可用于类和结构体</p>
<p>计算属性只是计算值，可用于类、结构体和枚举</p>
<p>属性观察器可用来检测属性值的变化，来触发自定义操作</p>
<p>属性包装器可用来复用多个属性的getter和setter中的代码</p>
<h2 id="9-1-存储属性"><a href="#9-1-存储属性" class="headerlink" title="9.1 存储属性"></a>9.1 存储属性</h2><h3 id="1）常量结构体实例的存储属性"><a href="#1）常量结构体实例的存储属性" class="headerlink" title="1）常量结构体实例的存储属性"></a>1）常量<strong>结构体</strong>实例的存储属性</h3><p>若一个结构体实例被声明为常量后，因为它是值类型，所以他的属性无论是不是可变属性，都不能改变。</p>
<h3 id="2）延时加载存储属性"><a href="#2）延时加载存储属性" class="headerlink" title="2）延时加载存储属性"></a>2）延时加载存储属性</h3><p>在属性声明前用<code>lazy</code>标识，且必须时<code>var</code>变量。</p>
<p>第一次被调用时才会计算其初始值。</p>
<p>可以避免类中不必要的初始化工作。</p>
<p>适用于：a）属性的值依赖于外部因素，且这些外部因素在构造结束之后才会知道的时候。b）属性的值需要大量的计算，因此要在需要的时候再计算。</p>
<p>若<code>lazy</code>属性在没有初始化时被多个线程访问，则无法保证该属性只会被初始化一次。</p>
<h2 id="9-2-计算属性（get-set）"><a href="#9-2-计算属性（get-set）" class="headerlink" title="9.2 计算属性（get/set）"></a>9.2 计算属性（<code>get/set</code>）</h2><p>提供一个getter和可选的setter，来间接获取或设置<strong>其他属性</strong>的值</p>
<h3 id="1）简化Setter声明"><a href="#1）简化Setter声明" class="headerlink" title="1）简化Setter声明"></a>1）简化Setter声明</h3><p>若没有定义新值的参数名，可使用默认名称<code>newValue</code></p>
<h3 id="2）简化Getter声明"><a href="#2）简化Getter声明" class="headerlink" title="2）简化Getter声明"></a>2）简化Getter声明</h3><p>若整个getter表达式是单一表达式，则可省略return</p>
<h3 id="3）只读计算属性"><a href="#3）只读计算属性" class="headerlink" title="3）只读计算属性"></a>3）只读计算属性</h3><p>只有getter没有setter，可以去掉<code>get</code>关键字和花括号</p>
<p>该属性必须使用var定义</p>
<h2 id="9-3-属性观察器（willset-didset）"><a href="#9-3-属性观察器（willset-didset）" class="headerlink" title="9.3 属性观察器（willset/didset）"></a>9.3 属性观察器（<code>willset/didset</code>）</h2><p>可为<em>自定义的存储属性</em>以及<em>继承的存储属性和计算属性</em>添加属性观察器。</p>
<p>对于继承的属性，通过重写属性来添加属性观察器</p>
<p>对于自定义的属性，通过setter来添加属性观察器</p>
<p><code>willset</code>新值设置前调用，会将新值作为参数传入，默认名称为<code>newValue</code></p>
<p><code>didset</code>新值设置后调用，会将旧值作为参数传入，默认名称为<code>oldValue</code></p>
<p>父类初始化完成之后，在子类中给父类属性赋值，会调用父类属性的<code>willset</code>和<code>didset</code></p>
<p>父类初始化之前，给子类属性赋值，不会调用字类属性的观察器</p>
<p>带有观察器的属性，通过in-out方式传入参数，也会调用观察器</p>
<h2 id="9-4-属性包装器"><a href="#9-4-属性包装器" class="headerlink" title="9.4 属性包装器"></a>9.4 属性包装器</h2><blockquote>
<p>使得所有使用同一个属性包装器的属性，均满足同一个规则</p>
<p>被包装值对外展示的变量名一定是<code>wrappedValue</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义属性包装器，使属性值小于等于12</span></span><br><span class="line"><span class="meta">@propertyWrapper</span>	<span class="comment">// 一定要有</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TwelveOrLess</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> number: <span class="type">Int</span>	<span class="comment">// 既是被包装属性的值</span></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.number = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> wrappedValue: <span class="type">Int</span> &#123;	<span class="comment">// 变量名一定是wrappedValue</span></span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> number &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; <span class="keyword">self</span>.number = <span class="built_in">min</span>(newValue, <span class="number">12</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用属性包装器</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SmallRectangle</span> </span>&#123;</span><br><span class="line">    @<span class="type">TwelveOrLess</span> <span class="keyword">var</span> height: <span class="type">Int</span>	<span class="comment">// 一定要有属性包装器名字</span></span><br><span class="line">    @<span class="type">TwelveOrLess</span> <span class="keyword">var</span> width: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> rect1 = <span class="type">SmallRectangle</span>()</span><br><span class="line">rect1.height = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(rect1.height)	<span class="comment">// 3</span></span><br><span class="line">rect1.height = <span class="number">30</span></span><br><span class="line"><span class="built_in">print</span>(rect1.height)	<span class="comment">// 12</span></span><br></pre></td></tr></table></figure>

<h3 id="1）设置被包装属性的初始值"><a href="#1）设置被包装属性的初始值" class="headerlink" title="1）设置被包装属性的初始值"></a>1）设置被包装属性的初始值</h3><blockquote>
<p>通过将实参传递给包装器，可设置被包装属性的初始化状态，并为其提供所需的其他参数，且能传到构造器中。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@propertyWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SmallNumber</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> maximum: <span class="type">Int</span>	<span class="comment">// 接收传入的实参，可控制被包装属性的最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> number: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> wrappedValue: <span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> number &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; number = <span class="built_in">min</span>(newValue, maximum) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        maximum = <span class="number">12</span></span><br><span class="line">        number = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(wrappedValue: <span class="type">Int</span>) &#123;	<span class="comment">//参数名一定要是wrappedValue</span></span><br><span class="line">        maximum = <span class="number">12</span></span><br><span class="line">        <span class="keyword">self</span>.number = wrappedValue</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(maximum: <span class="type">Int</span>, wrappedValue: <span class="type">Int</span>) &#123;	<span class="comment">//参数名一定要是wrappedValue</span></span><br><span class="line">        <span class="keyword">self</span>.maximum = maximum</span><br><span class="line">        <span class="keyword">self</span>.number = wrappedValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用 init()</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SmallRectangle2</span> </span>&#123;</span><br><span class="line">    @<span class="type">SmallNumber</span> <span class="keyword">var</span> height: <span class="type">Int</span>	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用 init(wrappedValue: Int)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SmallRectangle3</span> </span>&#123;</span><br><span class="line">    @<span class="type">SmallNumber</span> <span class="keyword">var</span> height: <span class="type">Int</span> = <span class="number">5</span>	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用 init(maximum: Int, wrappedValue: Int)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SmallRectangle4</span> </span>&#123;</span><br><span class="line">    @<span class="type">SmallNumber</span>(maximum: <span class="number">50</span>, wrappedValue: <span class="number">30</span>) <span class="keyword">var</span> height: <span class="type">Int</span>	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2）从属性包装器中呈现一个值"><a href="#2）从属性包装器中呈现一个值" class="headerlink" title="2）从属性包装器中呈现一个值"></a>2）从属性包装器中呈现一个值</h3><blockquote>
<p>被呈现值的参数名一定是<code>projectedValue</code></p>
<p>在调用包装器的结构体中，使用被呈现值时可省略<code>self.</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@propertyWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SmallVale</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> number: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> projectedValue: <span class="type">Bool</span>    <span class="comment">// 被呈现值，可用来标识被包装值是否被调整，可通过"$+实例名"来访问</span></span><br><span class="line">    <span class="keyword">var</span> wrappedValue: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> number &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> newValue &gt; <span class="number">12</span> &#123;</span><br><span class="line">                number = <span class="number">12</span></span><br><span class="line">                projectedValue = <span class="literal">true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                number = newValue</span><br><span class="line">                projectedValue = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        number = <span class="number">0</span></span><br><span class="line">        projectedValue = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SmallRectangle5</span> </span>&#123;</span><br><span class="line">    @<span class="type">SmallVale</span> <span class="keyword">var</span> height: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> rect5 = <span class="type">SmallRectangle5</span>()</span><br><span class="line">rect5.height = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(rect5.$height)	<span class="comment">//rect5.$height即是projectedValue的值</span></span><br></pre></td></tr></table></figure>

<h2 id="9-5-全局变量和局部变量"><a href="#9-5-全局变量和局部变量" class="headerlink" title="9.5 全局变量和局部变量"></a>9.5 全局变量和局部变量</h2><p>也可对全局变量和局部变量定义<strong>计算属性</strong>以及<strong>观察属性</strong>。</p>
<p>全局变量都是延迟计算，局部变量从不延迟计算。</p>
<h2 id="9-6-类型属性"><a href="#9-6-类型属性" class="headerlink" title="9.6 类型属性"></a>9.6 类型属性</h2><p>上述的属性是<strong>实例属性</strong>，每个实例的属性之间是独立的。</p>
<p><strong>类型属性</strong>是指，每个实例的类型属性之间是共享的。用于定义所有实例共享的数据，类似于静态变量。</p>
<p>存储型类型属性可以是常量或者变量，必须指定默认值，且是延迟初始化的。</p>
<p>计算型类型属性只能是变量。</p>
<h3 id="1）类型属性语法"><a href="#1）类型属性语法" class="headerlink" title="1）类型属性语法"></a>1）类型属性语法</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在`var`前加上`static`表示该变量是类型属性</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>/<span class="title">enum</span>/<span class="title">class</span> <span class="title">Name</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty = <span class="string">"abc"</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在`var`前加上`calss`表示该变量是允许字类重写的 计算类型属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">overrideableComputedTypeProperty</span>: <span class="title">Int</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2）获取和设置类型属性的值"><a href="#2）获取和设置类型属性的值" class="headerlink" title="2）获取和设置类型属性的值"></a>2）获取和设置类型属性的值</h3><p>通过类名来获取的</p>
<h1 id="10、方法"><a href="#10、方法" class="headerlink" title="10、方法"></a>10、方法</h1><p>类、结构体、枚举都能定义方法</p>
<h2 id="10-1-实例方法（Instance-Methods）"><a href="#10-1-实例方法（Instance-Methods）" class="headerlink" title="10.1 实例方法（Instance Methods）"></a>10.1 实例方法（Instance Methods）</h2><p>实例方法可以访问该类型的方法和属性。</p>
<p>实例方法只能被一个具体的实例调用。</p>
<h3 id="1）self-属性"><a href="#1）self-属性" class="headerlink" title="1）self 属性"></a>1）self 属性</h3><p>self完全等同于该实例本身。</p>
<p>在方法的参数名与某个属性名相同时，参数名享有优先权，可用self来标识属性名。</p>
<h3 id="2）在实例方法中修改值类型"><a href="#2）在实例方法中修改值类型" class="headerlink" title="2）在实例方法中修改值类型"></a>2）在实例方法中修改值类型</h3><p>结构体和枚举是值类型，其属性不能在方法中被修改。</p>
<p>若在方法定义的<code>func</code>前附加<code>mutating</code>，表面该方法是可变方法，则该方法可以修改属性。</p>
<p>但是常量结构体实例则不能调用可变方法。</p>
<p>在可变方法中也可以给<code>self</code> 赋值。</p>
<h2 id="10-2-类型方法"><a href="#10-2-类型方法" class="headerlink" title="10.2 类型方法"></a>10.2 类型方法</h2><p>在<code>func</code>前加上<code>static</code>，表明该方法是类型方法。</p>
<p>和类型属于一样，也可用<code>class</code>表示该方法可被字类重写。</p>
<p>类型方法中的<code>self</code>指的是类型本身，而不是某实例。</p>
<p>在类型方法中，可以直接通过其他<strong>类型方法名</strong>来调用，而不需要附加<strong>类型名</strong>。</p>
<h1 id="11、下标"><a href="#11、下标" class="headerlink" title="11、下标"></a>11、下标</h1><p>使用下标的索引代替存取方法来设置和获取值。</p>
<h2 id="11-1-下标语法"><a href="#11-1-下标语法" class="headerlink" title="11.1 下标语法"></a>11.1 下标语法</h2><p>可以设为<strong>可读可写</strong>，或者<strong>只读</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">subscript</span>(index: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">get</span> &#123; &#125;</span><br><span class="line">  <span class="keyword">set</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-2-类型下标"><a href="#11-2-类型下标" class="headerlink" title="11.2 类型下标"></a>11.2 类型下标</h2><p>类似于类型属性和类型方法，可用<code>static</code>和<code>calss</code></p>
<h1 id="12、继承"><a href="#12、继承" class="headerlink" title="12、继承"></a>12、继承</h1><p>只有类可以继承。</p>
<p>子类可以调用、访问、重写父类的方法、属性、下标。</p>
<p>为子类中继承而来的属性添加观察器可以得到他被修改的通知。</p>
<h2 id="12-1-基类"><a href="#12-1-基类" class="headerlink" title="12.1 基类"></a>12.1 基类</h2><p>只要一个类不继承其他的类，那他就是基类。</p>
<h2 id="12-2-重写"><a href="#12-2-重写" class="headerlink" title="12.2 重写"></a>12.2 重写</h2><p>在重写的方法、属性、下标前要加上<code>override</code>关键字</p>
<h3 id="1）访问超类的方法，属性及下标"><a href="#1）访问超类的方法，属性及下标" class="headerlink" title="1）访问超类的方法，属性及下标"></a>1）访问超类的方法，属性及下标</h3><p>在子类重写的方法、属性的setter/getter、下标中，使用<code>super</code>调用对应的方法即可访问父类的方法。</p>
<h3 id="2）重写属性的setter和getter"><a href="#2）重写属性的setter和getter" class="headerlink" title="2）重写属性的setter和getter"></a>2）重写属性的setter和getter</h3><p>不管父类是存储属性还是计算属性，子类都可定制setter和getter</p>
<p>可以将继承来的只读属性重写为读写属性，但不能将继承来的读写属性重写为只读属性。</p>
<p>若在重写的属性中提供了setter，那么一定也要提供getter。</p>
<h3 id="3）重写属性观察器"><a href="#3）重写属性观察器" class="headerlink" title="3）重写属性观察器"></a>3）重写属性观察器</h3><p>不能为继承来的常量存储属性或只读计算属性添加观察器。</p>
<p>不能同时为属性提供重写的setter和观察器。</p>
<h2 id="12-4-final防止重写或继承"><a href="#12-4-final防止重写或继承" class="headerlink" title="12.4 final防止重写或继承"></a>12.4 final防止重写或继承</h2><p>在定义前附加<code>final</code>可以防止方法、属性、下标被重写，或者防止类被继承</p>
<h1 id="13、构造过程"><a href="#13、构造过程" class="headerlink" title="13、构造过程"></a>13、构造过程</h1><h2 id="13-1-存储属性的初始赋值"><a href="#13-1-存储属性的初始赋值" class="headerlink" title="13.1 存储属性的初始赋值"></a>13.1 存储属性的初始赋值</h2><h3 id="1）构造器"><a href="#1）构造器" class="headerlink" title="1）构造器"></a>1）构造器</h3><h3 id="2）默认属性值"><a href="#2）默认属性值" class="headerlink" title="2）默认属性值"></a>2）默认属性值</h3><h2 id="13-2-自定义构造过程"><a href="#13-2-自定义构造过程" class="headerlink" title="13.2 自定义构造过程"></a>13.2 自定义构造过程</h2><h3 id="1）形参的构造过程"><a href="#1）形参的构造过程" class="headerlink" title="1）形参的构造过程"></a>1）形参的构造过程</h3><h3 id="2）形参命名和实参标签"><a href="#2）形参命名和实参标签" class="headerlink" title="2）形参命名和实参标签"></a>2）形参命名和实参标签</h3><h3 id="3）不带实参标签的构造器形参"><a href="#3）不带实参标签的构造器形参" class="headerlink" title="3）不带实参标签的构造器形参"></a>3）不带实参标签的构造器形参</h3><h3 id="4）可选属性类型"><a href="#4）可选属性类型" class="headerlink" title="4）可选属性类型"></a>4）可选属性类型</h3><h3 id="5）构造过程中常量属性的赋值"><a href="#5）构造过程中常量属性的赋值" class="headerlink" title="5）构造过程中常量属性的赋值"></a>5）构造过程中常量属性的赋值</h3><h2 id="13-3-默认构造器"><a href="#13-3-默认构造器" class="headerlink" title="13.3 默认构造器"></a>13.3 默认构造器</h2><h3 id="1）结构体的逐一成员构造器"><a href="#1）结构体的逐一成员构造器" class="headerlink" title="1）结构体的逐一成员构造器"></a>1）结构体的逐一成员构造器</h3><h2 id="13-4-值类型的构造器代理"><a href="#13-4-值类型的构造器代理" class="headerlink" title="13.4 值类型的构造器代理"></a>13.4 值类型的构造器代理</h2><h2 id="13-5-类的继承和构造过程"><a href="#13-5-类的继承和构造过程" class="headerlink" title="13.5 类的继承和构造过程"></a>13.5 类的继承和构造过程</h2><h3 id="1）指定构造器和便利构造器"><a href="#1）指定构造器和便利构造器" class="headerlink" title="1）指定构造器和便利构造器"></a>1）指定构造器和便利构造器</h3><h3 id="2）指定构造器和便利构造器的语法"><a href="#2）指定构造器和便利构造器的语法" class="headerlink" title="2）指定构造器和便利构造器的语法"></a>2）指定构造器和便利构造器的语法</h3><h3 id="3）类类型的构造器代理"><a href="#3）类类型的构造器代理" class="headerlink" title="3）类类型的构造器代理"></a>3）类类型的构造器代理</h3><h3 id="4）两段式构造过程"><a href="#4）两段式构造过程" class="headerlink" title="4）两段式构造过程"></a>4）两段式构造过程</h3><h3 id="5）构造器的继承和重写"><a href="#5）构造器的继承和重写" class="headerlink" title="5）构造器的继承和重写"></a>5）构造器的继承和重写</h3><h3 id="6）构造器的自动继承"><a href="#6）构造器的自动继承" class="headerlink" title="6）构造器的自动继承"></a>6）构造器的自动继承</h3><h3 id="7）指定构造器和便利构造器实践"><a href="#7）指定构造器和便利构造器实践" class="headerlink" title="7）指定构造器和便利构造器实践"></a>7）指定构造器和便利构造器实践</h3><h2 id="13-6-可失败构造器"><a href="#13-6-可失败构造器" class="headerlink" title="13.6 可失败构造器"></a>13.6 可失败构造器</h2><h3 id="1）枚举类型的可失败构造器"><a href="#1）枚举类型的可失败构造器" class="headerlink" title="1）枚举类型的可失败构造器"></a>1）枚举类型的可失败构造器</h3><h3 id="2）带原始值的枚举类型的可失败构造器"><a href="#2）带原始值的枚举类型的可失败构造器" class="headerlink" title="2）带原始值的枚举类型的可失败构造器"></a>2）带原始值的枚举类型的可失败构造器</h3><h3 id="3）构造失败的传递"><a href="#3）构造失败的传递" class="headerlink" title="3）构造失败的传递"></a>3）构造失败的传递</h3><h3 id="4）重写一个可失败构造器"><a href="#4）重写一个可失败构造器" class="headerlink" title="4）重写一个可失败构造器"></a>4）重写一个可失败构造器</h3><h3 id="5）init-可失败构造器"><a href="#5）init-可失败构造器" class="headerlink" title="5）init! 可失败构造器"></a>5）init! 可失败构造器</h3><h2 id="13-7-必要构造器"><a href="#13-7-必要构造器" class="headerlink" title="13.7 必要构造器"></a>13.7 必要构造器</h2><h2 id="13-8-通过闭包或函数设置属性的默认值"><a href="#13-8-通过闭包或函数设置属性的默认值" class="headerlink" title="13.8 通过闭包或函数设置属性的默认值"></a>13.8 通过闭包或函数设置属性的默认值</h2><h1 id="14、析构过程"><a href="#14、析构过程" class="headerlink" title="14、析构过程"></a>14、析构过程</h1><h2 id="14-1-析构过程原理"><a href="#14-1-析构过程原理" class="headerlink" title="14.1 析构过程原理"></a>14.1 析构过程原理</h2><h2 id="14-2-析构器实践"><a href="#14-2-析构器实践" class="headerlink" title="14.2 析构器实践"></a>14.2 析构器实践</h2><h1 id="15、可选链"><a href="#15、可选链" class="headerlink" title="15、可选链"></a>15、可选链</h1><h2 id="15-1-使用可选链式调用代替强制展开"><a href="#15-1-使用可选链式调用代替强制展开" class="headerlink" title="15.1 使用可选链式调用代替强制展开"></a>15.1 使用可选链式调用代替强制展开</h2><h2 id="15-2-为可选链式调用定义模型类"><a href="#15-2-为可选链式调用定义模型类" class="headerlink" title="15.2 为可选链式调用定义模型类"></a>15.2 为可选链式调用定义模型类</h2><h2 id="15-3-通过可选链式调用访问属性"><a href="#15-3-通过可选链式调用访问属性" class="headerlink" title="15.3 通过可选链式调用访问属性"></a>15.3 通过可选链式调用访问属性</h2><h2 id="15-4-通过可选链式调用来调用方法"><a href="#15-4-通过可选链式调用来调用方法" class="headerlink" title="15.4 通过可选链式调用来调用方法"></a>15.4 通过可选链式调用来调用方法</h2><h2 id="15-5-通过可选链式调用访问下标"><a href="#15-5-通过可选链式调用访问下标" class="headerlink" title="15.5 通过可选链式调用访问下标"></a>15.5 通过可选链式调用访问下标</h2><h3 id="1）访问可选类型的下标"><a href="#1）访问可选类型的下标" class="headerlink" title="1）访问可选类型的下标"></a>1）访问可选类型的下标</h3><h2 id="15-6-连接多层可选链式调用"><a href="#15-6-连接多层可选链式调用" class="headerlink" title="15.6 连接多层可选链式调用"></a>15.6 连接多层可选链式调用</h2><h2 id="15-7-在方法的可选返回值上进行可选链式调用"><a href="#15-7-在方法的可选返回值上进行可选链式调用" class="headerlink" title="15.7 在方法的可选返回值上进行可选链式调用"></a>15.7 在方法的可选返回值上进行可选链式调用</h2><h1 id="16、错误处理"><a href="#16、错误处理" class="headerlink" title="16、错误处理"></a>16、错误处理</h1><h2 id="16-1-表示与抛出错误"><a href="#16-1-表示与抛出错误" class="headerlink" title="16.1 表示与抛出错误"></a>16.1 表示与抛出错误</h2><h2 id="16-2-处理错误"><a href="#16-2-处理错误" class="headerlink" title="16.2 处理错误"></a>16.2 处理错误</h2><h3 id="1）用-throwing-函数传递错误"><a href="#1）用-throwing-函数传递错误" class="headerlink" title="1）用 throwing 函数传递错误"></a>1）用 throwing 函数传递错误</h3><h3 id="2）用-Do-Catch-处理错误"><a href="#2）用-Do-Catch-处理错误" class="headerlink" title="2）用 Do-Catch 处理错误"></a>2）用 Do-Catch 处理错误</h3><h3 id="3）将错误转换成可选值"><a href="#3）将错误转换成可选值" class="headerlink" title="3）将错误转换成可选值"></a>3）将错误转换成可选值</h3><h3 id="4）禁用错误传递"><a href="#4）禁用错误传递" class="headerlink" title="4）禁用错误传递"></a>4）禁用错误传递</h3><h2 id="16-3-指定清理操作"><a href="#16-3-指定清理操作" class="headerlink" title="16.3 指定清理操作"></a>16.3 指定清理操作</h2><h1 id="17、类型转换"><a href="#17、类型转换" class="headerlink" title="17、类型转换"></a>17、类型转换</h1><h2 id="17-1-为类型转换定义类层次"><a href="#17-1-为类型转换定义类层次" class="headerlink" title="17.1 为类型转换定义类层次"></a>17.1 为类型转换定义类层次</h2><h2 id="17-2-检查类型"><a href="#17-2-检查类型" class="headerlink" title="17.2 检查类型"></a>17.2 检查类型</h2><h2 id="17-3-向下转型"><a href="#17-3-向下转型" class="headerlink" title="17.3 向下转型"></a>17.3 向下转型</h2><h2 id="17-4-Any-和-AnyObject-的类型转换"><a href="#17-4-Any-和-AnyObject-的类型转换" class="headerlink" title="17.4 Any 和 AnyObject 的类型转换"></a>17.4 Any 和 AnyObject 的类型转换</h2><h1 id="18、嵌套类型"><a href="#18、嵌套类型" class="headerlink" title="18、嵌套类型"></a>18、嵌套类型</h1><h2 id="18-1-嵌套类型实践"><a href="#18-1-嵌套类型实践" class="headerlink" title="18.1 嵌套类型实践"></a>18.1 嵌套类型实践</h2><h2 id="18-2-引用嵌套类型"><a href="#18-2-引用嵌套类型" class="headerlink" title="18.2 引用嵌套类型"></a>18.2 引用嵌套类型</h2><h1 id="19、扩展"><a href="#19、扩展" class="headerlink" title="19、扩展"></a>19、扩展</h1><h2 id="19-1-扩展的语法"><a href="#19-1-扩展的语法" class="headerlink" title="19.1 扩展的语法"></a>19.1 扩展的语法</h2><h2 id="19-2-计算型属性"><a href="#19-2-计算型属性" class="headerlink" title="19.2 计算型属性"></a>19.2 计算型属性</h2><h2 id="19-3-构造器"><a href="#19-3-构造器" class="headerlink" title="19.3 构造器"></a>19.3 构造器</h2><h2 id="19-4方法"><a href="#19-4方法" class="headerlink" title="19.4方法"></a>19.4方法</h2><h3 id="1）可变实例方法"><a href="#1）可变实例方法" class="headerlink" title="1）可变实例方法"></a>1）可变实例方法</h3><h2 id="19-5-下标"><a href="#19-5-下标" class="headerlink" title="19.5 下标"></a>19.5 下标</h2><h2 id="19-6-嵌套类型"><a href="#19-6-嵌套类型" class="headerlink" title="19.6 嵌套类型"></a>19.6 嵌套类型</h2><h1 id="20、协议"><a href="#20、协议" class="headerlink" title="20、协议"></a>20、协议</h1><h2 id="20-1-协议语法"><a href="#20-1-协议语法" class="headerlink" title="20.1 协议语法"></a>20.1 协议语法</h2><h2 id="20-2-属性要求"><a href="#20-2-属性要求" class="headerlink" title="20.2 属性要求"></a>20.2 属性要求</h2><h2 id="20-3-方法要求"><a href="#20-3-方法要求" class="headerlink" title="20.3 方法要求"></a>20.3 方法要求</h2><h2 id="20-4-异变方法要求"><a href="#20-4-异变方法要求" class="headerlink" title="20.4 异变方法要求"></a>20.4 异变方法要求</h2><h2 id="20-5-构造器要求"><a href="#20-5-构造器要求" class="headerlink" title="20.5 构造器要求"></a>20.5 构造器要求</h2><h3 id="1）协议构造器要求的类实现"><a href="#1）协议构造器要求的类实现" class="headerlink" title="1）协议构造器要求的类实现"></a>1）协议构造器要求的类实现</h3><h3 id="2）可失败构造器要求"><a href="#2）可失败构造器要求" class="headerlink" title="2）可失败构造器要求"></a>2）可失败构造器要求</h3><h2 id="20-6-协议作为类型"><a href="#20-6-协议作为类型" class="headerlink" title="20.6 协议作为类型"></a>20.6 协议作为类型</h2><h2 id="20-7-委托"><a href="#20-7-委托" class="headerlink" title="20.7 委托"></a>20.7 委托</h2><h2 id="20-8-在扩展里添加协议遵循"><a href="#20-8-在扩展里添加协议遵循" class="headerlink" title="20.8 在扩展里添加协议遵循"></a>20.8 在扩展里添加协议遵循</h2><h2 id="20-9-有条件地遵循协议"><a href="#20-9-有条件地遵循协议" class="headerlink" title="20.9 有条件地遵循协议"></a>20.9 有条件地遵循协议</h2><h2 id="20-10-在扩展里声明采纳协议"><a href="#20-10-在扩展里声明采纳协议" class="headerlink" title="20.10 在扩展里声明采纳协议"></a>20.10 在扩展里声明采纳协议</h2><h2 id="20-11-协议类型的集合"><a href="#20-11-协议类型的集合" class="headerlink" title="20.11 协议类型的集合"></a>20.11 协议类型的集合</h2><h2 id="20-12-协议的继承"><a href="#20-12-协议的继承" class="headerlink" title="20.12 协议的继承"></a>20.12 协议的继承</h2><h2 id="20-13-类专属的协议"><a href="#20-13-类专属的协议" class="headerlink" title="20.13 类专属的协议"></a>20.13 类专属的协议</h2><h2 id="20-14-协议合成"><a href="#20-14-协议合成" class="headerlink" title="20.14 协议合成"></a>20.14 协议合成</h2><h2 id="20-15-检查协议一致性"><a href="#20-15-检查协议一致性" class="headerlink" title="20.15 检查协议一致性"></a>20.15 检查协议一致性</h2><h2 id="20-16-可选的协议要求"><a href="#20-16-可选的协议要求" class="headerlink" title="20.16 可选的协议要求"></a>20.16 可选的协议要求</h2><h2 id="20-17-协议扩展"><a href="#20-17-协议扩展" class="headerlink" title="20.17 协议扩展"></a>20.17 协议扩展</h2><h3 id="1）提供默认实现"><a href="#1）提供默认实现" class="headerlink" title="1）提供默认实现"></a>1）提供默认实现</h3><h3 id="2）为协议扩展添加限制条件"><a href="#2）为协议扩展添加限制条件" class="headerlink" title="2）为协议扩展添加限制条件"></a>2）为协议扩展添加限制条件</h3><h1 id="21、泛型"><a href="#21、泛型" class="headerlink" title="21、泛型"></a>21、泛型</h1><h2 id="21-1-泛型解决的问题"><a href="#21-1-泛型解决的问题" class="headerlink" title="21.1 泛型解决的问题"></a>21.1 泛型解决的问题</h2><h2 id="21-2-泛型函数"><a href="#21-2-泛型函数" class="headerlink" title="21.2 泛型函数"></a>21.2 泛型函数</h2><h2 id="21-3-类型参数"><a href="#21-3-类型参数" class="headerlink" title="21.3 类型参数"></a>21.3 类型参数</h2><h2 id="21-4-命名类型参数"><a href="#21-4-命名类型参数" class="headerlink" title="21.4 命名类型参数"></a>21.4 命名类型参数</h2><h2 id="21-5-泛型类型"><a href="#21-5-泛型类型" class="headerlink" title="21.5 泛型类型"></a>21.5 泛型类型</h2><h2 id="21-6-泛型扩展"><a href="#21-6-泛型扩展" class="headerlink" title="21.6 泛型扩展"></a>21.6 泛型扩展</h2><h2 id="21-7-类型约束"><a href="#21-7-类型约束" class="headerlink" title="21.7 类型约束"></a>21.7 类型约束</h2><h3 id="1）类型约束语法"><a href="#1）类型约束语法" class="headerlink" title="1）类型约束语法"></a>1）类型约束语法</h3><h3 id="2）类型约束实践"><a href="#2）类型约束实践" class="headerlink" title="2）类型约束实践"></a>2）类型约束实践</h3><h2 id="21-8-关联类型"><a href="#21-8-关联类型" class="headerlink" title="21.8 关联类型"></a>21.8 关联类型</h2><h3 id="1）关联类型实践"><a href="#1）关联类型实践" class="headerlink" title="1）关联类型实践"></a>1）关联类型实践</h3><h3 id="2）扩展现有类型来指定关联类型"><a href="#2）扩展现有类型来指定关联类型" class="headerlink" title="2）扩展现有类型来指定关联类型"></a>2）扩展现有类型来指定关联类型</h3><h3 id="3）给关联类型添加约束"><a href="#3）给关联类型添加约束" class="headerlink" title="3）给关联类型添加约束"></a>3）给关联类型添加约束</h3><h3 id="4）在关联类型约束里使用协议"><a href="#4）在关联类型约束里使用协议" class="headerlink" title="4）在关联类型约束里使用协议"></a>4）在关联类型约束里使用协议</h3><h2 id="21-9-泛型-Where-语句"><a href="#21-9-泛型-Where-语句" class="headerlink" title="21.9 泛型 Where 语句"></a>21.9 泛型 Where 语句</h2><h2 id="21-10-具有泛型-Where-子句的扩展"><a href="#21-10-具有泛型-Where-子句的扩展" class="headerlink" title="21.10 具有泛型 Where 子句的扩展"></a>21.10 具有泛型 Where 子句的扩展</h2><h2 id="21-11-具有泛型-Where-子句的关联类型"><a href="#21-11-具有泛型-Where-子句的关联类型" class="headerlink" title="21.11 具有泛型 Where 子句的关联类型"></a>21.11 具有泛型 Where 子句的关联类型</h2><h2 id="21-12-泛型下标"><a href="#21-12-泛型下标" class="headerlink" title="21.12 泛型下标"></a>21.12 泛型下标</h2><h1 id="22、不透明类型"><a href="#22、不透明类型" class="headerlink" title="22、不透明类型"></a>22、不透明类型</h1><h2 id="22-1-不透明类型解决的问题"><a href="#22-1-不透明类型解决的问题" class="headerlink" title="22.1 不透明类型解决的问题"></a>22.1 不透明类型解决的问题</h2><h2 id="22-2-返回不透明类型"><a href="#22-2-返回不透明类型" class="headerlink" title="22.2 返回不透明类型"></a>22.2 返回不透明类型</h2><h2 id="22-3-不透明类型和协议类型的区别"><a href="#22-3-不透明类型和协议类型的区别" class="headerlink" title="22.3 不透明类型和协议类型的区别"></a>22.3 不透明类型和协议类型的区别</h2><h1 id="23、自动引用计数"><a href="#23、自动引用计数" class="headerlink" title="23、自动引用计数"></a>23、自动引用计数</h1><h2 id="23-1-自动引用计数的工作机制"><a href="#23-1-自动引用计数的工作机制" class="headerlink" title="23.1 自动引用计数的工作机制"></a>23.1 自动引用计数的工作机制</h2><h2 id="23-2-自动引用计数实践"><a href="#23-2-自动引用计数实践" class="headerlink" title="23.2 自动引用计数实践"></a>23.2 自动引用计数实践</h2><h2 id="23-3-类实例之间的循环强引用"><a href="#23-3-类实例之间的循环强引用" class="headerlink" title="23.3 类实例之间的循环强引用"></a>23.3 类实例之间的循环强引用</h2><h2 id="23-4-解决实例之间的循环强引用"><a href="#23-4-解决实例之间的循环强引用" class="headerlink" title="23.4 解决实例之间的循环强引用"></a>23.4 解决实例之间的循环强引用</h2><h3 id="1）弱引用"><a href="#1）弱引用" class="headerlink" title="1）弱引用"></a>1）弱引用</h3><h3 id="2）无主引用"><a href="#2）无主引用" class="headerlink" title="2）无主引用"></a>2）无主引用</h3><h3 id="3）无主引用和隐式解包可选值属性"><a href="#3）无主引用和隐式解包可选值属性" class="headerlink" title="3）无主引用和隐式解包可选值属性"></a>3）无主引用和隐式解包可选值属性</h3><h2 id="23-5-闭包的循环强引用"><a href="#23-5-闭包的循环强引用" class="headerlink" title="23.5 闭包的循环强引用"></a>23.5 闭包的循环强引用</h2><h2 id="23-6-解决闭包的循环强引用"><a href="#23-6-解决闭包的循环强引用" class="headerlink" title="23.6 解决闭包的循环强引用"></a>23.6 解决闭包的循环强引用</h2><h3 id="1）定义捕获列表"><a href="#1）定义捕获列表" class="headerlink" title="1）定义捕获列表"></a>1）定义捕获列表</h3><h3 id="2）弱引用和无主引用"><a href="#2）弱引用和无主引用" class="headerlink" title="2）弱引用和无主引用"></a>2）弱引用和无主引用</h3><h1 id="24、内存安全"><a href="#24、内存安全" class="headerlink" title="24、内存安全"></a>24、内存安全</h1><h2 id="24-1-理解内存访问冲突"><a href="#24-1-理解内存访问冲突" class="headerlink" title="24.1 理解内存访问冲突"></a>24.1 理解内存访问冲突</h2><h3 id="1）内存访问性质"><a href="#1）内存访问性质" class="headerlink" title="1）内存访问性质"></a>1）内存访问性质</h3><h2 id="24-2-In-Out-参数的访问冲突"><a href="#24-2-In-Out-参数的访问冲突" class="headerlink" title="24.2 In-Out 参数的访问冲突"></a>24.2 In-Out 参数的访问冲突</h2><h2 id="24-3-方法里-self-的访问冲突"><a href="#24-3-方法里-self-的访问冲突" class="headerlink" title="24.3 方法里 self 的访问冲突"></a>24.3 方法里 self 的访问冲突</h2><h2 id="24-4-属性的访问冲突"><a href="#24-4-属性的访问冲突" class="headerlink" title="24.4 属性的访问冲突"></a>24.4 属性的访问冲突</h2><h1 id="25、访问控制"><a href="#25、访问控制" class="headerlink" title="25、访问控制"></a>25、访问控制</h1><h2 id="25-1-模块和源文件"><a href="#25-1-模块和源文件" class="headerlink" title="25.1 模块和源文件"></a>25.1 模块和源文件</h2><h2 id="25-2-访问级别"><a href="#25-2-访问级别" class="headerlink" title="25.2 访问级别"></a>25.2 访问级别</h2><h3 id="1）访问级别基本原则"><a href="#1）访问级别基本原则" class="headerlink" title="1）访问级别基本原则"></a>1）访问级别基本原则</h3><h3 id="2）默认访问级别"><a href="#2）默认访问级别" class="headerlink" title="2）默认访问级别"></a>2）默认访问级别</h3><h3 id="3）单-target-应用程序的访问级别"><a href="#3）单-target-应用程序的访问级别" class="headerlink" title="3）单 target 应用程序的访问级别"></a>3）单 target 应用程序的访问级别</h3><h3 id="4）框架的访问级别"><a href="#4）框架的访问级别" class="headerlink" title="4）框架的访问级别"></a>4）框架的访问级别</h3><h3 id="5）单元测试-target-的访问级别"><a href="#5）单元测试-target-的访问级别" class="headerlink" title="5）单元测试 target 的访问级别"></a>5）单元测试 target 的访问级别</h3><h2 id="25-3-访问控制语法"><a href="#25-3-访问控制语法" class="headerlink" title="25.3 访问控制语法"></a>25.3 访问控制语法</h2><h2 id="25-4-自定义类型"><a href="#25-4-自定义类型" class="headerlink" title="25.4 自定义类型"></a>25.4 自定义类型</h2><h3 id="1）元组类型"><a href="#1）元组类型" class="headerlink" title="1）元组类型"></a>1）元组类型</h3><h3 id="2）函数类型"><a href="#2）函数类型" class="headerlink" title="2）函数类型"></a>2）函数类型</h3><h3 id="3）枚举类型"><a href="#3）枚举类型" class="headerlink" title="3）枚举类型"></a>3）枚举类型</h3><h3 id="4）嵌套类型"><a href="#4）嵌套类型" class="headerlink" title="4）嵌套类型"></a>4）嵌套类型</h3><h2 id="25-5-子类"><a href="#25-5-子类" class="headerlink" title="25.5 子类"></a>25.5 子类</h2><h2 id="25-6-常量、变量、属性、下标"><a href="#25-6-常量、变量、属性、下标" class="headerlink" title="25.6 常量、变量、属性、下标"></a>25.6 常量、变量、属性、下标</h2><h3 id="1）Getter-和-Setter"><a href="#1）Getter-和-Setter" class="headerlink" title="1）Getter 和 Setter"></a>1）Getter 和 Setter</h3><h2 id="25-7-构造器"><a href="#25-7-构造器" class="headerlink" title="25.7 构造器"></a>25.7 构造器</h2><h3 id="1）默认构造器"><a href="#1）默认构造器" class="headerlink" title="1）默认构造器"></a>1）默认构造器</h3><h3 id="2）结构体默认的成员逐一构造器"><a href="#2）结构体默认的成员逐一构造器" class="headerlink" title="2）结构体默认的成员逐一构造器"></a>2）结构体默认的成员逐一构造器</h3><h2 id="25-8-协议"><a href="#25-8-协议" class="headerlink" title="25.8 协议"></a>25.8 协议</h2><h3 id="1）协议继承"><a href="#1）协议继承" class="headerlink" title="1）协议继承"></a>1）协议继承</h3><h3 id="2）协议遵循"><a href="#2）协议遵循" class="headerlink" title="2）协议遵循"></a>2）协议遵循</h3><h2 id="25-9-Extension"><a href="#25-9-Extension" class="headerlink" title="25.9 Extension"></a>25.9 Extension</h2><h3 id="1）Extension-的私有成员"><a href="#1）Extension-的私有成员" class="headerlink" title="1）Extension 的私有成员"></a>1）Extension 的私有成员</h3><h2 id="25-10-泛型"><a href="#25-10-泛型" class="headerlink" title="25.10 泛型"></a>25.10 泛型</h2><h2 id="25-11-类型别名"><a href="#25-11-类型别名" class="headerlink" title="25.11 类型别名"></a>25.11 类型别名</h2><h1 id="26、高级运算符"><a href="#26、高级运算符" class="headerlink" title="26、高级运算符"></a>26、高级运算符</h1><h2 id="26-1-位运算符"><a href="#26-1-位运算符" class="headerlink" title="26.1 位运算符"></a>26.1 位运算符</h2><h3 id="1）Bitwise-NOT-Operator（按位取反运算符）"><a href="#1）Bitwise-NOT-Operator（按位取反运算符）" class="headerlink" title="1）Bitwise NOT Operator（按位取反运算符）"></a>1）Bitwise NOT Operator（按位取反运算符）</h3><h3 id="2）Bitwise-AND-Operator（按位与运算符）"><a href="#2）Bitwise-AND-Operator（按位与运算符）" class="headerlink" title="2）Bitwise AND Operator（按位与运算符）"></a>2）Bitwise AND Operator（按位与运算符）</h3><h3 id="3）Bitwise-OR-Operator（按位或运算符）"><a href="#3）Bitwise-OR-Operator（按位或运算符）" class="headerlink" title="3）Bitwise OR Operator（按位或运算符）"></a>3）Bitwise OR Operator（按位或运算符）</h3><h3 id="4）Bitwise-XOR-Operator（按位异或运算符）"><a href="#4）Bitwise-XOR-Operator（按位异或运算符）" class="headerlink" title="4）Bitwise XOR Operator（按位异或运算符）"></a>4）Bitwise XOR Operator（按位异或运算符）</h3><h3 id="5）Bitwise-Left-and-Right-Shift-Operators（按位左移、右移运算符）"><a href="#5）Bitwise-Left-and-Right-Shift-Operators（按位左移、右移运算符）" class="headerlink" title="5）Bitwise Left and Right Shift Operators（按位左移、右移运算符）"></a>5）Bitwise Left and Right Shift Operators（按位左移、右移运算符）</h3><h2 id="26-2-溢出运算符"><a href="#26-2-溢出运算符" class="headerlink" title="26.2 溢出运算符"></a>26.2 溢出运算符</h2><h3 id="1）数值溢出"><a href="#1）数值溢出" class="headerlink" title="1）数值溢出"></a>1）数值溢出</h3><h2 id="26-3-优先级和结合性"><a href="#26-3-优先级和结合性" class="headerlink" title="26.3 优先级和结合性"></a>26.3 优先级和结合性</h2><h3 id="1）运算符函数"><a href="#1）运算符函数" class="headerlink" title="1）运算符函数"></a>1）运算符函数</h3><h3 id="2）前缀和后缀运算符"><a href="#2）前缀和后缀运算符" class="headerlink" title="2）前缀和后缀运算符"></a>2）前缀和后缀运算符</h3><h3 id="3）复合赋值运算符"><a href="#3）复合赋值运算符" class="headerlink" title="3）复合赋值运算符"></a>3）复合赋值运算符</h3><h3 id="4）等价运算符"><a href="#4）等价运算符" class="headerlink" title="4）等价运算符"></a>4）等价运算符</h3><h2 id="26-4-自定义运算符"><a href="#26-4-自定义运算符" class="headerlink" title="26.4 自定义运算符"></a>26.4 自定义运算符</h2><h3 id="1）自定义中缀运算符的优先级"><a href="#1）自定义中缀运算符的优先级" class="headerlink" title="1）自定义中缀运算符的优先级"></a>1）自定义中缀运算符的优先级</h3>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"><i class="fa fa-tag"></i> 笔记</a>
          
            <a href="/tags/IOS/" rel="tag"><i class="fa fa-tag"></i> IOS</a>
          
            <a href="/tags/Swift/" rel="tag"><i class="fa fa-tag"></i> Swift</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/%E3%80%8AThe%20Swift%20Programming%20Language%E3%80%8Bin%20Chinese--0.%E5%89%8D%E8%A8%80.html" rel="next" title="《The Swift Programming Language》in Chinese--0.前言">
                <i class="fa fa-chevron-left"></i> 《The Swift Programming Language》in Chinese--0.前言
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



		<div class="post-spread">
		  
		</div>
  </div>


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/upload/image/avatar.jpg"
                alt="LTP" />
            
              <p class="site-author-name" itemprop="name">LTP</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7Carchive">
              
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/MrConfused" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:liutianpeng_cs@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.youtube.com/playlist?list=LLvAZqNn-b97237v1dLcT1Qg" target="_blank" title="YouTube">
                      
                        <i class="fa fa-fw fa-youtube"></i>YouTube</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1、基本运算符"><span class="nav-text">1、基本运算符</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2、字符串String和字符Character"><span class="nav-text">2、字符串String和字符Character</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3、集合类型"><span class="nav-text">3、集合类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-集合类型"><span class="nav-text">3.1 集合类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-数组（Array）"><span class="nav-text">3.2 数组（Array）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）构建方法"><span class="nav-text">1）构建方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）访问和修改"><span class="nav-text">2）访问和修改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3）数组遍历"><span class="nav-text">3）数组遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-集合（Sets）"><span class="nav-text">3.3 集合（Sets）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）集合类型的哈希值"><span class="nav-text">1）集合类型的哈希值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）创建集合"><span class="nav-text">2）创建集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3）访问和修改"><span class="nav-text">3）访问和修改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4）集合遍历"><span class="nav-text">4）集合遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5）集合操作"><span class="nav-text">5）集合操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-字典（Dictionary）"><span class="nav-text">3.4 字典（Dictionary）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）创建字典"><span class="nav-text">1）创建字典</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）访问和修改-1"><span class="nav-text">2）访问和修改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3）字典遍历"><span class="nav-text">3）字典遍历</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4、控制流"><span class="nav-text">4、控制流</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-for-in"><span class="nav-text">4.1 for-in</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-while"><span class="nav-text">4.2 while</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-条件语句"><span class="nav-text">4.3 条件语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）if"><span class="nav-text">1）if</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）switch"><span class="nav-text">2）switch</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-控制转移"><span class="nav-text">4.4 控制转移</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）带标签的语句"><span class="nav-text">1）带标签的语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）guard"><span class="nav-text">2）guard</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-检测API可用性"><span class="nav-text">4.5 检测API可用性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5、函数"><span class="nav-text">5、函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-可变参数"><span class="nav-text">5.1 可变参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-输入输出参数"><span class="nav-text">5.2 输入输出参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-函数类型"><span class="nav-text">5.3 函数类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）作为参数类型"><span class="nav-text">1）作为参数类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）作为返回值类型"><span class="nav-text">2）作为返回值类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-嵌套函数"><span class="nav-text">5.4 嵌套函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6、闭包"><span class="nav-text">6、闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-优化"><span class="nav-text">6.1 优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-值捕获"><span class="nav-text">6.2 值捕获</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-闭包是引用类型"><span class="nav-text">6.3 闭包是引用类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-逃逸闭包"><span class="nav-text">6.4 逃逸闭包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5-自动闭包"><span class="nav-text">6.5 自动闭包</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7、枚举"><span class="nav-text">7、枚举</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-语法"><span class="nav-text">7.1 语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-用Switch语句匹配枚举值"><span class="nav-text">7.2 用Switch语句匹配枚举值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-enum成员对遍历"><span class="nav-text">7.3 enum成员对遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-关联值"><span class="nav-text">7.4 关联值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-5-原始值-默认值"><span class="nav-text">7.5 原始值&#x2F;默认值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）原始值的隐式赋值"><span class="nav-text">1）原始值的隐式赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）使用原始值初始化枚举实例"><span class="nav-text">2）使用原始值初始化枚举实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-6-递归枚举"><span class="nav-text">7.6 递归枚举</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8、类和结构体"><span class="nav-text">8、类和结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-类和结构体的对比"><span class="nav-text">8.1 类和结构体的对比</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）共同点"><span class="nav-text">1）共同点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）类的特点"><span class="nav-text">2）类的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3）类的缺点"><span class="nav-text">3）类的缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4）结构体的逐一构造器"><span class="nav-text">4）结构体的逐一构造器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5）总结"><span class="nav-text">5）总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-结构体和枚举是值类型"><span class="nav-text">8.2 结构体和枚举是值类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-类是引用类型"><span class="nav-text">8.3 类是引用类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）恒等运算符-和"><span class="nav-text">1）恒等运算符&#x3D;&#x3D;&#x3D;和!&#x3D;&#x3D;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-指针"><span class="nav-text">2) 指针</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9、属性"><span class="nav-text">9、属性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1-存储属性"><span class="nav-text">9.1 存储属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）常量结构体实例的存储属性"><span class="nav-text">1）常量结构体实例的存储属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）延时加载存储属性"><span class="nav-text">2）延时加载存储属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2-计算属性（get-set）"><span class="nav-text">9.2 计算属性（get&#x2F;set）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）简化Setter声明"><span class="nav-text">1）简化Setter声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）简化Getter声明"><span class="nav-text">2）简化Getter声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3）只读计算属性"><span class="nav-text">3）只读计算属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-3-属性观察器（willset-didset）"><span class="nav-text">9.3 属性观察器（willset&#x2F;didset）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-4-属性包装器"><span class="nav-text">9.4 属性包装器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）设置被包装属性的初始值"><span class="nav-text">1）设置被包装属性的初始值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）从属性包装器中呈现一个值"><span class="nav-text">2）从属性包装器中呈现一个值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-5-全局变量和局部变量"><span class="nav-text">9.5 全局变量和局部变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-6-类型属性"><span class="nav-text">9.6 类型属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）类型属性语法"><span class="nav-text">1）类型属性语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）获取和设置类型属性的值"><span class="nav-text">2）获取和设置类型属性的值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10、方法"><span class="nav-text">10、方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1-实例方法（Instance-Methods）"><span class="nav-text">10.1 实例方法（Instance Methods）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）self-属性"><span class="nav-text">1）self 属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）在实例方法中修改值类型"><span class="nav-text">2）在实例方法中修改值类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-2-类型方法"><span class="nav-text">10.2 类型方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11、下标"><span class="nav-text">11、下标</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#11-1-下标语法"><span class="nav-text">11.1 下标语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-2-类型下标"><span class="nav-text">11.2 类型下标</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12、继承"><span class="nav-text">12、继承</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#12-1-基类"><span class="nav-text">12.1 基类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-2-重写"><span class="nav-text">12.2 重写</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）访问超类的方法，属性及下标"><span class="nav-text">1）访问超类的方法，属性及下标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）重写属性的setter和getter"><span class="nav-text">2）重写属性的setter和getter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3）重写属性观察器"><span class="nav-text">3）重写属性观察器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-4-final防止重写或继承"><span class="nav-text">12.4 final防止重写或继承</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13、构造过程"><span class="nav-text">13、构造过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#13-1-存储属性的初始赋值"><span class="nav-text">13.1 存储属性的初始赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）构造器"><span class="nav-text">1）构造器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）默认属性值"><span class="nav-text">2）默认属性值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-2-自定义构造过程"><span class="nav-text">13.2 自定义构造过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）形参的构造过程"><span class="nav-text">1）形参的构造过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）形参命名和实参标签"><span class="nav-text">2）形参命名和实参标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3）不带实参标签的构造器形参"><span class="nav-text">3）不带实参标签的构造器形参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4）可选属性类型"><span class="nav-text">4）可选属性类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5）构造过程中常量属性的赋值"><span class="nav-text">5）构造过程中常量属性的赋值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-3-默认构造器"><span class="nav-text">13.3 默认构造器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）结构体的逐一成员构造器"><span class="nav-text">1）结构体的逐一成员构造器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-4-值类型的构造器代理"><span class="nav-text">13.4 值类型的构造器代理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-5-类的继承和构造过程"><span class="nav-text">13.5 类的继承和构造过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）指定构造器和便利构造器"><span class="nav-text">1）指定构造器和便利构造器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）指定构造器和便利构造器的语法"><span class="nav-text">2）指定构造器和便利构造器的语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3）类类型的构造器代理"><span class="nav-text">3）类类型的构造器代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4）两段式构造过程"><span class="nav-text">4）两段式构造过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5）构造器的继承和重写"><span class="nav-text">5）构造器的继承和重写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6）构造器的自动继承"><span class="nav-text">6）构造器的自动继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7）指定构造器和便利构造器实践"><span class="nav-text">7）指定构造器和便利构造器实践</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-6-可失败构造器"><span class="nav-text">13.6 可失败构造器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）枚举类型的可失败构造器"><span class="nav-text">1）枚举类型的可失败构造器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）带原始值的枚举类型的可失败构造器"><span class="nav-text">2）带原始值的枚举类型的可失败构造器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3）构造失败的传递"><span class="nav-text">3）构造失败的传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4）重写一个可失败构造器"><span class="nav-text">4）重写一个可失败构造器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5）init-可失败构造器"><span class="nav-text">5）init! 可失败构造器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-7-必要构造器"><span class="nav-text">13.7 必要构造器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-8-通过闭包或函数设置属性的默认值"><span class="nav-text">13.8 通过闭包或函数设置属性的默认值</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14、析构过程"><span class="nav-text">14、析构过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#14-1-析构过程原理"><span class="nav-text">14.1 析构过程原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-2-析构器实践"><span class="nav-text">14.2 析构器实践</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#15、可选链"><span class="nav-text">15、可选链</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#15-1-使用可选链式调用代替强制展开"><span class="nav-text">15.1 使用可选链式调用代替强制展开</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-2-为可选链式调用定义模型类"><span class="nav-text">15.2 为可选链式调用定义模型类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-3-通过可选链式调用访问属性"><span class="nav-text">15.3 通过可选链式调用访问属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-4-通过可选链式调用来调用方法"><span class="nav-text">15.4 通过可选链式调用来调用方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-5-通过可选链式调用访问下标"><span class="nav-text">15.5 通过可选链式调用访问下标</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）访问可选类型的下标"><span class="nav-text">1）访问可选类型的下标</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-6-连接多层可选链式调用"><span class="nav-text">15.6 连接多层可选链式调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-7-在方法的可选返回值上进行可选链式调用"><span class="nav-text">15.7 在方法的可选返回值上进行可选链式调用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#16、错误处理"><span class="nav-text">16、错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#16-1-表示与抛出错误"><span class="nav-text">16.1 表示与抛出错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-2-处理错误"><span class="nav-text">16.2 处理错误</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）用-throwing-函数传递错误"><span class="nav-text">1）用 throwing 函数传递错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）用-Do-Catch-处理错误"><span class="nav-text">2）用 Do-Catch 处理错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3）将错误转换成可选值"><span class="nav-text">3）将错误转换成可选值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4）禁用错误传递"><span class="nav-text">4）禁用错误传递</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-3-指定清理操作"><span class="nav-text">16.3 指定清理操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#17、类型转换"><span class="nav-text">17、类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#17-1-为类型转换定义类层次"><span class="nav-text">17.1 为类型转换定义类层次</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-2-检查类型"><span class="nav-text">17.2 检查类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-3-向下转型"><span class="nav-text">17.3 向下转型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-4-Any-和-AnyObject-的类型转换"><span class="nav-text">17.4 Any 和 AnyObject 的类型转换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#18、嵌套类型"><span class="nav-text">18、嵌套类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#18-1-嵌套类型实践"><span class="nav-text">18.1 嵌套类型实践</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-2-引用嵌套类型"><span class="nav-text">18.2 引用嵌套类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#19、扩展"><span class="nav-text">19、扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#19-1-扩展的语法"><span class="nav-text">19.1 扩展的语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-2-计算型属性"><span class="nav-text">19.2 计算型属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-3-构造器"><span class="nav-text">19.3 构造器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-4方法"><span class="nav-text">19.4方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）可变实例方法"><span class="nav-text">1）可变实例方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-5-下标"><span class="nav-text">19.5 下标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-6-嵌套类型"><span class="nav-text">19.6 嵌套类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#20、协议"><span class="nav-text">20、协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#20-1-协议语法"><span class="nav-text">20.1 协议语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-2-属性要求"><span class="nav-text">20.2 属性要求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-3-方法要求"><span class="nav-text">20.3 方法要求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-4-异变方法要求"><span class="nav-text">20.4 异变方法要求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-5-构造器要求"><span class="nav-text">20.5 构造器要求</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）协议构造器要求的类实现"><span class="nav-text">1）协议构造器要求的类实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）可失败构造器要求"><span class="nav-text">2）可失败构造器要求</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-6-协议作为类型"><span class="nav-text">20.6 协议作为类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-7-委托"><span class="nav-text">20.7 委托</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-8-在扩展里添加协议遵循"><span class="nav-text">20.8 在扩展里添加协议遵循</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-9-有条件地遵循协议"><span class="nav-text">20.9 有条件地遵循协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-10-在扩展里声明采纳协议"><span class="nav-text">20.10 在扩展里声明采纳协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-11-协议类型的集合"><span class="nav-text">20.11 协议类型的集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-12-协议的继承"><span class="nav-text">20.12 协议的继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-13-类专属的协议"><span class="nav-text">20.13 类专属的协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-14-协议合成"><span class="nav-text">20.14 协议合成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-15-检查协议一致性"><span class="nav-text">20.15 检查协议一致性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-16-可选的协议要求"><span class="nav-text">20.16 可选的协议要求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-17-协议扩展"><span class="nav-text">20.17 协议扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）提供默认实现"><span class="nav-text">1）提供默认实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）为协议扩展添加限制条件"><span class="nav-text">2）为协议扩展添加限制条件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#21、泛型"><span class="nav-text">21、泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#21-1-泛型解决的问题"><span class="nav-text">21.1 泛型解决的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-2-泛型函数"><span class="nav-text">21.2 泛型函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-3-类型参数"><span class="nav-text">21.3 类型参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-4-命名类型参数"><span class="nav-text">21.4 命名类型参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-5-泛型类型"><span class="nav-text">21.5 泛型类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-6-泛型扩展"><span class="nav-text">21.6 泛型扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-7-类型约束"><span class="nav-text">21.7 类型约束</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）类型约束语法"><span class="nav-text">1）类型约束语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）类型约束实践"><span class="nav-text">2）类型约束实践</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-8-关联类型"><span class="nav-text">21.8 关联类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）关联类型实践"><span class="nav-text">1）关联类型实践</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）扩展现有类型来指定关联类型"><span class="nav-text">2）扩展现有类型来指定关联类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3）给关联类型添加约束"><span class="nav-text">3）给关联类型添加约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4）在关联类型约束里使用协议"><span class="nav-text">4）在关联类型约束里使用协议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-9-泛型-Where-语句"><span class="nav-text">21.9 泛型 Where 语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-10-具有泛型-Where-子句的扩展"><span class="nav-text">21.10 具有泛型 Where 子句的扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-11-具有泛型-Where-子句的关联类型"><span class="nav-text">21.11 具有泛型 Where 子句的关联类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-12-泛型下标"><span class="nav-text">21.12 泛型下标</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#22、不透明类型"><span class="nav-text">22、不透明类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#22-1-不透明类型解决的问题"><span class="nav-text">22.1 不透明类型解决的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-2-返回不透明类型"><span class="nav-text">22.2 返回不透明类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-3-不透明类型和协议类型的区别"><span class="nav-text">22.3 不透明类型和协议类型的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#23、自动引用计数"><span class="nav-text">23、自动引用计数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#23-1-自动引用计数的工作机制"><span class="nav-text">23.1 自动引用计数的工作机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-2-自动引用计数实践"><span class="nav-text">23.2 自动引用计数实践</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-3-类实例之间的循环强引用"><span class="nav-text">23.3 类实例之间的循环强引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-4-解决实例之间的循环强引用"><span class="nav-text">23.4 解决实例之间的循环强引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）弱引用"><span class="nav-text">1）弱引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）无主引用"><span class="nav-text">2）无主引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3）无主引用和隐式解包可选值属性"><span class="nav-text">3）无主引用和隐式解包可选值属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-5-闭包的循环强引用"><span class="nav-text">23.5 闭包的循环强引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-6-解决闭包的循环强引用"><span class="nav-text">23.6 解决闭包的循环强引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）定义捕获列表"><span class="nav-text">1）定义捕获列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）弱引用和无主引用"><span class="nav-text">2）弱引用和无主引用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#24、内存安全"><span class="nav-text">24、内存安全</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#24-1-理解内存访问冲突"><span class="nav-text">24.1 理解内存访问冲突</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）内存访问性质"><span class="nav-text">1）内存访问性质</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-2-In-Out-参数的访问冲突"><span class="nav-text">24.2 In-Out 参数的访问冲突</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-3-方法里-self-的访问冲突"><span class="nav-text">24.3 方法里 self 的访问冲突</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-4-属性的访问冲突"><span class="nav-text">24.4 属性的访问冲突</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#25、访问控制"><span class="nav-text">25、访问控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#25-1-模块和源文件"><span class="nav-text">25.1 模块和源文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-2-访问级别"><span class="nav-text">25.2 访问级别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）访问级别基本原则"><span class="nav-text">1）访问级别基本原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）默认访问级别"><span class="nav-text">2）默认访问级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3）单-target-应用程序的访问级别"><span class="nav-text">3）单 target 应用程序的访问级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4）框架的访问级别"><span class="nav-text">4）框架的访问级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5）单元测试-target-的访问级别"><span class="nav-text">5）单元测试 target 的访问级别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-3-访问控制语法"><span class="nav-text">25.3 访问控制语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-4-自定义类型"><span class="nav-text">25.4 自定义类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）元组类型"><span class="nav-text">1）元组类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）函数类型"><span class="nav-text">2）函数类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3）枚举类型"><span class="nav-text">3）枚举类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4）嵌套类型"><span class="nav-text">4）嵌套类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-5-子类"><span class="nav-text">25.5 子类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-6-常量、变量、属性、下标"><span class="nav-text">25.6 常量、变量、属性、下标</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）Getter-和-Setter"><span class="nav-text">1）Getter 和 Setter</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-7-构造器"><span class="nav-text">25.7 构造器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）默认构造器"><span class="nav-text">1）默认构造器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）结构体默认的成员逐一构造器"><span class="nav-text">2）结构体默认的成员逐一构造器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-8-协议"><span class="nav-text">25.8 协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）协议继承"><span class="nav-text">1）协议继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）协议遵循"><span class="nav-text">2）协议遵循</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-9-Extension"><span class="nav-text">25.9 Extension</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）Extension-的私有成员"><span class="nav-text">1）Extension 的私有成员</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-10-泛型"><span class="nav-text">25.10 泛型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-11-类型别名"><span class="nav-text">25.11 类型别名</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#26、高级运算符"><span class="nav-text">26、高级运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#26-1-位运算符"><span class="nav-text">26.1 位运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）Bitwise-NOT-Operator（按位取反运算符）"><span class="nav-text">1）Bitwise NOT Operator（按位取反运算符）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）Bitwise-AND-Operator（按位与运算符）"><span class="nav-text">2）Bitwise AND Operator（按位与运算符）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3）Bitwise-OR-Operator（按位或运算符）"><span class="nav-text">3）Bitwise OR Operator（按位或运算符）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4）Bitwise-XOR-Operator（按位异或运算符）"><span class="nav-text">4）Bitwise XOR Operator（按位异或运算符）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5）Bitwise-Left-and-Right-Shift-Operators（按位左移、右移运算符）"><span class="nav-text">5）Bitwise Left and Right Shift Operators（按位左移、右移运算符）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-2-溢出运算符"><span class="nav-text">26.2 溢出运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）数值溢出"><span class="nav-text">1）数值溢出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-3-优先级和结合性"><span class="nav-text">26.3 优先级和结合性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）运算符函数"><span class="nav-text">1）运算符函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）前缀和后缀运算符"><span class="nav-text">2）前缀和后缀运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3）复合赋值运算符"><span class="nav-text">3）复合赋值运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4）等价运算符"><span class="nav-text">4）等价运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-4-自定义运算符"><span class="nav-text">26.4 自定义运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）自定义中缀运算符的优先级"><span class="nav-text">1）自定义中缀运算符的优先级</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LTP</span>

  
</div>









<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('-1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.4"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.4"></script>


  

  
  <!-- 小红心 -->
  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
